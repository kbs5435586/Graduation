5~6
6~7
7~8
포인터 기본 개념 이해
*pt, pt, &pt 어떻게 상호작용 하는지
위에 두개가 존나 오래걸렸음

* 포인터 변수 : 포인터 변수가 기리키는 메모리 주소에 저장된 값
& 변수 : 변수에 할당된 메모리의 시작 주소

포인터 사용하려면 필요한 데이터 2가지
1. 포인터
2. 포인터가 가리키는 객체

int x = 100;
int* pt; // 포인터 변수 pt의 내용은 int형이다
pt = &x; // 포인터 변수 pt에 변수 x의 주소 값을 할당하여 x를 가리킨다

&x = x가 저장되있는 메모리 시작점
&pt = pt가 저장되있는 메모리 시작점
pt = 포인터 pt가 가리키는 주소
*pt = 그 포인터 pt가 가리키는 값

위에를 이해하면 void* 사용하는 방법도 자연스럽게 이해됨
========================================================
8~9
포인터랑 1차 배열 관계
지웅이 검사
포인터 2,3차 배열관계 - 별로 안중요

포인터랑 함수 관계
포인터를 사용하면 다른 함수의 변수를 간접으로 접근 가능
(그 변수의 주소값을 가리키니까!)
그래서 배열도 전달 가능, 그리고 처리한 결과값 반환받을때 사용

함수 포인터 = 우리가 메인문 밖에 함수 선언해두고
그 함수 이름을 호출 했을때 메인문 밖의 함수에 타고 들어가는게 함수 포인터임
즉 함수 호출할때 함수 이름 쓰는거 자체가 함수 포인터
========================================================
9~10
10~11
11~12
12~1
구조체 선언 사용
병석이랑 잡담
구조체 초기화
구조체 배열
구조체 포인터 = 사실상 구조체를 자료형처럼 생각하면 일반 포인터랑 같음
그럼 -> 또한 가리키는 구조체 내부의 맴버변수의 주소값을 가리키는 포인터

구조체와 함수
함수의 매개변수로 구조체 전달방법 2가지
1. 구조체 전체의 값을 복사하여 전달 -> 말 그대로 복사, 메모리, 시간 전부 많이 소요
2. 구조체의 포인터를 사용하여 전달 -> 복사 없이 직접 접근한다? 존나 효율적

만약 읽어올때 외부 함수에서 읽기만 할거면 함수 인자값으로 구조체 쓸때 const
붙이는게 안전함

공용체 유니온
유니온은 cpu의 레지스터를 활용할때 주로 사용, 일반적으로 안씀
하나의 메모리 영역을 여러 멤버가 공동으로 사용하는데 동시에는 못쓰고
마지막에 저장한 하나의 멤버의 데이터만 저장됨

enum은 관련 있는 정수형의 상수 목록 집합을 사용자가 정의한 자료형
데이터에 임의의 정수값 지정하면 그 뒤에는 무조건 +1 값들
이넘도 구조체라서 typedef 가능함
========================================================
1~2
연습문제 및 에셋 구매, 유니티 설치, 에셋 파일 추출
2분할 압축하고 병석이 보내주기
========================================================
2~3
3~4
키보드에서 입력한 문자열을 저장한 후 문자열을 역순으로 출력해봐라 문제
최대한 배운거 다 써서 풀어보기

원래 배열로 문자열 저장하고 역순 출력해보는건데 그러면 너무 쉬워서
반대로 배열을 안쓰고 저장받아서 역순 출력해보는걸 시도

char* 첫 시도 실패, char* 변수 메모리 초기화 해줘야함

string으로 시도, 배열처럼 낱개 진입하려고하니 얘는 begin, end를 써야함
구글링해보니 ㅅㅂ algorithm 라이브러리에 reverse 함수가 있음
STL, 스트링 다 써먹을 수 있음, 내부에 역순시킬 시작점이랑 끝점 정해주면됨

역순출력 함수의 매개변수를 스트링 포인터로 해서 인자값에 레퍼런스 붙여서 직접접근
함수 내부에서 reverse함수 써서 역순 출력

char* 랑 char[] 는 선언과 동시에 초기화 하지 않으면 못쓰는건가?
얘네 둘도 초기화만 해놓고 cin으로 받아서 쓰고 싶은데
char*는 생각해보니까 포인터고 저장공간이 없으니 cin할때 에러나는게 당연
char[] 도 마찬가지.. 초기화안하면 에러나도 초기화하면 한칸으로 잡아버려서
cin은 되는데 stack 터진다고 프로그램 터짐

그래서 문제 조건이 배열로 일단 문자열을 받고 char*를 쓰든 char[]를 쓰든 포인터로
넘겨주든 배열로 넘겨주든 그랬던거였구만..
========================================================
4~5
5~6
함수를 정의하고 프로그램에서 함수 사용하는거 = 함수를 호출한다
아무것도 없이 변수 쓰는거 = 지역 변수
static 붙이면 현재 파일, 현재 함수에서만 유효한 정적 변수
extern 다른 파일에서도 참조 가능한 외부변수

콜 바이 레퍼런스 할때
매개변수를 포인터로 설정하는거랑 참조 변수로 선언하는거 2가지 방법

원래 변수명 앞에 & 붙이면 주소값 되는거 아니였나?
이미 선언된 변수에 &를 붙이면 주소값이 되는데
새로 선언하면서 변수 이름 앞에 & 붙이면 참조자를 선언하게 된다
일종의 이미 선언한 변수를 다름이름으로 연동짓는 행위
int &num2 = num1 했을때
num2에 10을 더하면 num1도 더해져있다

참조자 쓰는게 더 쉬운데 그럼 포인터는 왜 쓰냐?
포인터는 널값이 있는데 참조자는 널 값이 없음
그래서 결정되지 않거나 모르는 값이 들어올 수 있는 경우 포인터로 해야함
그리고 참조자는 한번 객체가 정해지면 바꿀 수 없는데
포인터는 주소값을 변경해서 지정 객체 변경이 가능함

그리고 매개변수로 배열을 쓰면 복사본이 아니라 원본으로 된다!!
왜냐면 배열명 자체가 첫번째 원소의 주솟값이니까
그리고 얘도 원본 건드리는거니까 읽기 전용으로 쓸거면 const 쓰는 습관

구조체는 똑같이 콜바이 벨류랑 레퍼런스임
인라인 함수는 함수 오버헤드 줄이려고 크기가 작은 함수에 쓰게 만든건게
요즘 컴파일러는 알아서 인라인화 시킴 따라서 알 필요x
 
템플릿 함수 = 어떤 자료형이 될지 모를때 공통으로 모든 자료형에 사용할 수 있는 함수
오버로딩 발생시 순서!
명시적 특수 템플릿 함수 > 템플릿 함수 > 템플릿 아닌 일반 함수

재귀함수 = 함수안에 똑같은 함수 또 호출해서 수식 반복 시키는거
========================================================
총 13시간