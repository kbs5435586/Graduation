11~12
12~1
겜서버 프레임웍 들어갈 클래스들 간단하게 정리
서버 클래스 - IOCP 서버
오브젝트 클래스 - NPC+유저+지형지물 (부모-자식 예정)
군집 처리 클래스
유한 상태 기계를 굳이 클래스로 파야하나? NPC 클래스 안에 일단 구현하는걸로

오브젝트 클래스 자식으로 npc 클래스를 만들어 그 내부에 유한 상태기계 구현후
군집 처리 클래스를 npc 클래스 내부에 맴버 변수로 읽어와서 유한 상태 기계 상태에
따라 다르게 군집 처리하면 될거 같음
  
클라에선 스레드 파지말고 그냥 서버cpp 하나 만들어서
WSAAsyncSelect로 리시브, 뮤텍스로 업데이트에 영향 안주게 동기화, 이후 샌드(일반 샌드함수)
서버에서 타이머 큐로 클라에 보내주는 타이밍 동시에 맞춰주기

1~2
2~3
지웅이 얘기

3~4
4~5
패킷에 겜서버 때처럼 npc 상태도 보내서 클라에 WSAAsyncSelect로 받은 결과를
상태별로 나누어 npc 데이터 전송

WSAAsyncSelect가 네트웍 이벤트가 발생할때마다 hWnd 윈도우로 메시지를 보내야할때,
보내야 하는 메시지가 wMsg 매개변수로 지정한 메시지로 처리하고 싶을때 사용
비동기모드는 걍 내가 설명하면됨

그리고 착각한게 npc 상태 분류용 패킷은 패킷대로 따로고
WSAAsyncSelect 함수에 IEvent 매개변수의 결과값들이 따로 정해진게 있음
FD_ 로 시작되는 애들, FD_READ로 소켓 수신상태로 바꾸고 recv하고
FD_WRITE로 소켓 송신상태로 바꾸고 send하고

아니다 상태가 아니라 말그대로 이벤트임, FD_로 시작하는 애들이
이벤트 발생을 알려주는거 뿐임
따라서 recv 함수를 통해 수신할게 있으면 FD_READ 상태로 이벤트가 처리되고
FD_READ 상태 내부에서 처리해주고 recv 이후 과정을 처리해주고
send 할게 있으면 FD_WRITE 상태 안에 처리해주면 됨

나중에 구체적으로 WSAAsyncSelect 처리해야되는 날이 왔을때 
https://clansim.tistory.com/56 참고, 제일 잘 나와있음

6시간
----------------------------------------

5~6 엄마랑 외출
6~8 낮잠

----------------------------------------

8~9
9~10
10~11
11~12
<string 구체적으로>
char str[], char *str, char str[6] 차이점 / 왼쪽과 string 차이점
get+ignore(첫 공백시 종료), getline(첫 엔터나 EOF시 종료), read(null 안읽음, 파일입출력)
getline, write 이용한 출력 비교, 

<c스타일과 호환>
c_str() 이용한 c문자열 호환
접두사 str~, ~n~ n숫자만큼, ~i~ 대소문자 구분없이, ~r~ 역순처리
~cat 결합, ~cmp 비교, ~cpy 복사, ~len 길이

<기본 배열 이론>
초기화 방법 {0}, {0, }, 애초에 [ ] 빈칸으로 선언=초기화할때 알아서 참자 수 계산함 
배열 선언 후 문자열 넣을땐 무조건 strcpy 사용
버블 정렬 알고리즘 -> 오름차순
2차원, 3차원 배열 초기화 방법
함수에 인자값으로 배열 전달할때

4시간

총 10시간