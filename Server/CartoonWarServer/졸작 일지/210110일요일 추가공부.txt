생성자는 기본 클래스 -> 파생 클래스 순서로 호출되지만
소멸자는 파생 클래스 -> 기본 클래스 순서로 호출된다
그래서 소멸할때 상위 클래스의 소멸자에 virtual을 붙이면 하위 클래스
소멸자부터 호출이 되어 이럴 '가상 소멸자' 라고함, 소멸자는 가상으로 정의하는게 좋음

가상 소멸자를 사용 안하면 파생 클래스의 소멸자가 호출되지 않아서
파생 클래스의 생성자에게 메모리를 생성하는 부분이 있으면 해제되지 않고 종료된다

상위의 기본 클래스는 반드시 가상 소멸자 필수
어떤 클래스라도 가상 함수를 가지면 소멸자도 가상 소멸자여야함
기본 클래스가 아닌 다형성을 갖지 않는 클래스는 가상 클래스 선언 X
다형성 = 기본 클래스의 가상 함수가 파생 클래스에서 재정의 되어 실행되는것

오버로드는 함수 이름이 같고 매개 변수가 다를때 일어나는 재정의
오버라이드는 파생 클래스에서 상속받은 기본 클래스의 가상 함수와 같은 이름과
같은 매개변수를 가질때 일어나는 재정의
어떤 식으로 재정의가 일어나냐, 파생 클래스에서 재정의하면 기본 클래스에 정의한
멤버 함수가 무시되고 새로 정의한 함수가 동작함
이렇게 작동하려면 기본 클래스에서 virtual 예약어를 붙여 멤버 함수를 가상 함수로 정의

이렇게 가상 함수로 만들면 프로그램이 실행 중에 동적 바인딩을 한다
즉, 포인터가 아니라 실제 객체의 자료형을 알아서 검색하여 동적으로 찾아서 호출함
virtual 안붙인 함수들은 정적 바인딩을 한다, 즉 컴파일시 바로 호출
파생 클래스의 재정의 함수는 가상 함수와 매개 변수는 같아야 하지만 리턴은 달라도됌

그런데 이런 가상 함수의 사용은 포인터와 참조자에만 작용하므로 객체를 값으로 전달할때
가상 함수 호출이 불가능함

가상 함수 끝에 =0 붙여서 얘 함수 안에는 아무 내용 없지만 파생 클래스에서 재정의해
사용할거다 라고 인터페이스 표시, 단 이걸 순수 가상 함수라고 하는데 순수 가상 함수가
하나라도 있으면 그 클래스는 추상 클래스가 되어버림 -> 자기 자신 객체 선언 불가