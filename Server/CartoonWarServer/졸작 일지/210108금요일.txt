2~3
3~4
4~5
WSAAsyncSelect모델이 모든 소켓과 관련된 메세지를 하나의 윈도우,
즉 하나의 윈도우 프로시저로 전달해서 멀티스레드를 사용 안해도
여러 소켓이 처리가 가능함

윈속 열고
리슨 소켓 선언하고
그 이후 WSAAsyncSelect(리슨소켓,hWnd,WM_SOCKET,FD_ACCEP | FD_CLOSE);
이후 바인드랑 리슨 ( 서버쪽으로 클라면 바로 커넥트 하면 될듯)
이후 LRESULT CALLBACK WndProc 내부에서 switch(uMsg)에 case WM_SOCKET
그 안에서 에러 예외처리 해주고 에러 아닐시 switch(WSAGETSELECTEVENT(lParam))
에서 case FD_ACCEPT 일때 연결처리, FD_READ 일때 recv, FD_WRITE일때 send
FD_CLOSE일때 RemoveSocketInfo(wParam);

근데 이건 서버일 경우도 클라에선 받고 보내기만 할거니까...
WSAAsyncSelect(클라소켓, hWnd, WM_SOCKET, FD_READ | FD_WRITE); 하면 될거같은데

여러 사이트 뒤져보니 데이버 보내고 받는건 전부다 이 코드 고정인듯
case FD_READ:

    ptr = GetSocketInfo(wParam);      // 소켓 검색
    if(ptr->recvbytes > 0) {                // send 를 해야하므로 return 을 한다는 것이다.

                                                       // 처음엔 recvdelayed = FALSE
        ptr->recvdelayed = TRUE;
        return;
    }

    retval = recv(ptr->sock, ptr->buf, BUFSIZE, 0);

    ptr->recvbytes = retval;             // 값을 넣어줬으니 다음에는 WRITE

case FD_WRITE:
    ptr = GetSocketInfo(wParam);
    if(ptr->recvbytes <= ptr->sendbytes)
       return;
    // 데이터 보내기
    retval = send(ptr->sock, ptr->buf + ptr->sendbytes, ptr->recvbytes - ptr->sendbytes, 0);

    .....

    ptr->sendbytes += retval;
    // 받은 데이터를 모두 보냈는지 체크
    if(ptr->recvbytes == ptr->sendbytes) {
        ptr->recvbytes = ptr->sendbytes = 0;
        if(ptr->recvdelayed) {
            ptr->recvdelayed = FALSE;
            PostMessage(hWnd, WM_SOCKET, wParam, FD_READ);
        }
    }

다렉도 MFC인가? https://3001ssw.tistory.com/40 참고해서
프로그래스바 만들었듯이 윈도우 창으로 간단하게 로비 만들어도 괜찮을듯하다
===========================================================
5~6
6~7
메모리 관리 방법 3가지
정적 메모리 (auto) : 선언된 위치의 블록 내에서 선언된 시점에서
할당되고 블록 벗어나면 해제
자동적 메모리 (static) : static 선언한 위치에서 할당, 프로그램 종료시 해제
동적 메모리 (dynamic) : 블록, 프로그램 상관없이 뉴,말록으로 지정하는 순간 할당
delete,free 하는 순간 해제, 포인터 필수사용하고 사용한 후엔 포인터 해제 해줘야함

동적 메모리 가장 큰 장점은 내가 원할때 할당하고 해제할 수 있다는거
그래서 배열 구조체 클래스처럼 크기가 클 수 있는 애들은 동적 메모리 자주 사용
namespace 사용법
===========================================================
7~8
8~9
9~10
클래스 기본 개념 정리

객체(오브젝트) = 클래스형의 변수, 모든 객체는 데이터(상태)와 행위를 가짐
객체의 상태는 멤버 변수로 표현, 객체의 행위는 멤버 함수로 표현
객체의 상태는 캡슐화하여 외부에 비공개, 행위는 객체 간에 정보 교환 위해 공개

객체는 개념을 형상화한것, 인스턴스는 현재 존재하는것
클래스를 멤버 변수로 선언해서 객체를 만드는것 = 인스턴스 = 객체

클래스는 사용자가 정의한 새로운 자료형, 클래스를 자료형으로 선언한 변수 생성후 사용
클래스 생성시 필요한 공간 / 1. 클래스 선언 구역, 2. 클래스 정의 구역, 3. 클래스 사용 구역

클래스 자체는 참조형이므로 heap 영역, 객체는 stack 영역

접근 지정자 3가지
public : 모든 클래스에서 접근 가능
protected : 자식 클래스는 접근 가능
private : 오로지 내부 맴버만 접근 가능, friend도 가능

안전을 위해서 최대한 멤버 변수는 private으로 선언해 캡슐화 하고
겟터 셋터 이용해서 멤버 변수 접근하기

생성자 소멸자 안쓰면 컴파일러는 널문으로 자동처리
생성자 작성하면 컴파일러가 기본 생성자 생성 안함
생성자 선언한 경우에는 무조건 소멸자도 선언해야함
매개 변수 있는 생성자 사용하여 생성자 오버로드 가능
===========================================================
10~11
11~12
저녁 및 앞으로 지웅이 관리 얘기

소멸자는 매개변수 없고 직접 호출도 못함
생성자의 구현 영역이 끝날대 소멸자 호출함

생성자 맴버 변수를 const로 선언할때는 생성자(n): 변수명(n)으로 선언
const 맴버 함수는 해당 함수 내부 정보인 어떠한 멤버값도 변경하지 않는 함수
즉 맴버 변수의 값을 변경하지 않을 맴버 함수만 const함수로 선언
void 함수명 (매개변수) const;

주로 읽기용으로 쓸 함수 쓸때 매개 변수 조차 변경 안일어나게 하기 위해 사용함
static으로 맴버 변수 선언하면 클래스 내에서 복사가 아닌 원본을 다같이 사용
c++에서는 가능하면 static 사용하지 말것
===========================================================
12~1
1~2
2~3
3~4 
코드연습+이론
객체 동적 할당
this 포인터 이용한 자기 참조
this 포인터 = 객체에 대한 포인터로 맴버 함수를 소유한 각 객체를 가리킴
즉 객체에 대한 주소
매개 변수의 이름이랑 맴버 변수의 이름이 같을때 this로 구분 가능함 (굳이?)

static 이용한 정적 맴버 함수는 this 포인터로 매개변수 못가르킴

시발 맴버 함수를 참조로 선언하고 *this 리턴시키면 바로바로 . 으로 이어서 선언
가능한데 시발 누가 왜 이렇게 써 ㅋㅋㅋㅋㅋㅋㅋㅋㅋ 혼돈의 카오스네

객체 배열
객체 포인터 배열
복사 생성자

클래스 상속
다중 상속 가능하긴한데 코드가 난해해지니까 사용하지 말것
가상함수(마무리부분 마저 더 봐야함)
===========================================================
총 14시간
